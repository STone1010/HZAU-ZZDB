# 数据的机器级表示

- 不管以什么形态出现，在计算机内部，数据最终都由机器指令来处理。
- 机器级数据分两大类：
  - 数值数据:无符号/带符号整数、浮点数中实数)、十进制数
  - 非数值数据:逻辑数(包括位串)、西文字符和汉字

- 真值:现实中世界中数的值
- 机器数:计算机内部的0/1序列

## 数值的表示格式

### 进位计数制

> B 二进制    	O八进制   	 D十进制   	 H十六进制

- 整数转换规则:除2取余，直至商为0，先得低位(除基取余法)
- 小数转换规则:乘2取整，至小数部分为0或取近似值(乘基取整法)

### 定点数

**定点数:**数据格式中小数点的位置固定不变

计算机中的定点数只采用**纯整数**或者**纯小数**表示

三种定点编码方式：原码、补码、反码

#### 原码

##### 定义

- 最高位为**符号位0/1**+**数值的绝对值形式**

##### 表示范围

- 正数有$2^{n-1}-1$个（去掉00000……）
- 负数有$2^{n-1}-1$个（去掉11111……）

##### **特点**

- 值[+0]，[-0]的原码分别为00000、10000，形式不唯一；
- 运算时需对符号位进行处理。

#### 补码

##### **定义**

![1719131342606](C:\Users\86152\AppData\Local\Temp\1719131342606.png)

**[X]补=$2^n$+X     （MOD  $2^n$）**

##### 表示规律(书本例题P30-P32)

0正1负；

正数的补码就是原码，负数的补码按照从右至左，见1后反

![1719131456945](C:\Users\86152\AppData\Local\Temp\1719131456945.png)

##### 表示范围

- 正数有$2^{n-1}-1$个（去掉00000……）
- 负数有$2^{n-1}$个

##### **特点：**

补码正是利用补数概念，把负数映射到正数域中(平移模值，小数的模为2，n位整数的模为$2^n$)从而将数的正负符号数码化，将减法运算转换为加法运算。



#### 反码

X是正数，[X]反=[X]原；X是负数，符号+数值取反。

0正1负，各位取反；可利用反码来求补码，即在末尾加一。



#### 移码

> 主要用来表示浮点数阶码

**0负1正，数码位同补码**

![1719132528061](C:\Users\86152\AppData\Local\Temp\1719132528061.png)

便于浮点数加减运算时对阶操作

![1719132674101](C:\Users\86152\AppData\Local\Temp\1719132674101.png)

### 整数

#### 无符号符号数

编码中没有符号位，能表示的最大值大于位数相同的带符号整数

#### 有无符号数的差别：

- 扩充操作有差别

  无符号数一般使用0扩展，有符号数使用符号扩展

- 数的比较有差异

  无符号数不用考虑最高位

- 溢出判断有差异

### 浮点数

![1719134121327](C:\Users\86152\AppData\Local\Temp\1719134121327.png)

对**尾数**和**指数**分别编码，就可表示一个浮点数
$$
N=M×r^E
$$

#### IEEE 754

IEEE754尾数带有一个隐藏位，偏置常数与其他相比也少一。

![Screenshot_20240623_172343](C:\Users\86152\Desktop\计组\Screenshot_20240623_172343.jpg)

![1719134286220](C:\Users\86152\AppData\Local\Temp\1719134286220.png)



#### 浮点数的分类：

- 0的表示

  阶码与尾数都为零，符号位有效表示正负

- 无穷的表示

  阶码全1，尾数全0，符号位有效表示正负

- 非数

  阶码全1，尾数不全为0

- 非规格化数

  阶码全0，尾数高位为0但不全为0

  非规格化数处理阶码下溢，是的出现比最小规格化数还小的数时程序也能继续运行下去。

#### 浮点数的表示范围：

![1719134887787](C:\Users\86152\AppData\Local\Temp\1719134887787.png)

![1719138844093](C:\Users\86152\AppData\Local\Temp\1719138844093.png)

最大的单精度数：$+1.11111111×2^{127}$

浮点数的大数吃小数问题ppt上

#### 十进制数的表示

- ASCII码
- BCD码

## 非数值数据的表示

### 逻辑数据

用一位表示。例： 真：1/假：0.

可参考flag寄存器

### 西文字符

常用7位ASCII码表示

### 汉字

GB2312国标码->汉字机内码

## 数据宽度

- 字长：即机器字长吗，指定点运算数据通路的宽度
- 字：表示呗处理信息的单位，用来度量数据类型的宽度

字和字长的宽度可以一阿姨那个，也可不同



## 数据的存储和排列

- 大端方式：将数据的最高有效字节MSB存放在低地址单元中
- 小端方式：将数据的最低有效字节LSB存放在低地址单元中。

例：在100—103存放FFFF0001H：

![1719140563710](C:\Users\86152\AppData\Local\Temp\1719140563710.png)

## 对齐

> 要求数据段地址是相应边界的地址

![1719141259582](C:\Users\86152\AppData\Local\Temp\1719141259582.png)

提问2：S2是将结构体与结构体之间也要对其，不对齐的地址为s，s+9,s+18，s+27，只有第一个元素满足四字节对齐要求。

## 数据校验码

码距

任意两个合法码之间不相同的二进制位数的最小值

- 要具有差错能力，则码距>1
- 合理增大码距，就能提高发现错误的能力
  - 若码距d为奇数，则能发现d-1位错，或能纠正(d-1)/2位错若
  - 码距d为偶数，则能发现d/2位错，并能纠正(d/2-1)位错

### 奇偶校验码

> 基本思想:**增加一位校验位**，根据接收端的数据求出新校验位，根据新校验位确定是否发生了错误。常用于存储器读写检查，或ASCII字符传送过程中的检查。

当实际数据中“1”的个数为偶数的时候，校验位是“0”，反之校验位是“1”，换句话说，**数据位（N位）和 校验位（1位）组成的 编码数据（N+1位）中，将总共包含偶数个1**。 

检查 **编码数据（N+1位）**，如果其包含**偶数**个 **1**，则 **校验通过** 

奇偶校验码只能发现奇数位错，且不能确定出错位置，因此不具有纠错能力

若计算最终校验位得到P*

- 若P*=1，奇数个错
- 若P*=0,   正确或偶数个错

### 海明校验码

> 海明校验全码实际上就是一种多重奇偶校验码

#### 校验位数的确定：

$2^k$>=1(无错)+n(数据位错)+k(校验位错)

![1719159655344](C:\Users\86152\AppData\Local\Temp\1719159655344.png)

说明：M7（第11位）：1011，故由P1,P2,P4识别。

校验位Pi的位置在2的i-1次方，但是除了最高位

- 如果故障字各位全部是0，则表示没有发生错误
- 如果故障字中有且仅有一位为1,则表示校验位中有一位出错,不需要纠正（即故障位为检验码）
- 如果故障字中多位为1（即故障位为数据位）,则表示有一个教据位出错,其在码字中的出错位由故障字的数值来决定所正时只要将出错位取反即可

校验过程例：![1719159882295](C:\Users\86152\AppData\Local\Temp\1719159882295.png)

### (循环冗余校验)CRC码

假设M(X)为-个n位的二进制数据

- 将 M(x)左移K位,用一个K+1位的生成多项式G(x)去除M(x)得到一个K位余数
- 将K位余数(校验位)拼接到M(x)后面一起传输
- 将接收到的数据与校验位用同样的生成多项式G(w)相除,,或余数为0，则无错

具有纠错能力:

- 不同出错位置的余数不同。
- 只要出错位置相同余数一定相同，与码字无关。
- 通信中一般只检错不纠错



